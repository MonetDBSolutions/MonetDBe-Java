package org.monetdb.monetdbe;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * A {@link Statement} suitable for the MonetDB embedded database.
 *
 * The object used for executing a static SQL statement and returning
 * the results it produces.
 *
 * By default, only one {@link ResultSet} object per Statement object can be
 * open at the same time. Therefore, if the reading of one ResultSet
 * object is interleaved with the reading of another, each must have
 * been generated by different {@link Statement} objects. All execution methods
 * in the Statement interface implicitly close a Statement's current
 * ResultSet object if an open one exists.
 */
public class MonetStatement extends MonetWrapper implements Statement {
    /** This statement's parent connection object */
    protected MonetConnection conn;
    /** The current result set */
    protected MonetResultSet resultSet;
    /** Batched SQL queries to execute */
    protected List<String> batch;
    /** Current updateCount (number of affected rows) */
    protected int updateCount = -1;
    /** Current updateCount (number of affected rows) for executeLarge methods  */
    protected long largeUpdateCount = -1;
    /** Timeout before aborting a query execution */
    private int queryTimeout = 0;
    /** Is this statement closed? */
    private boolean closed = false;
    /** Should this statement be closed when it's result set object is? */
    private boolean closeOnCompletion = false;
    /** The stack of warnings for this Statement object */
    private SQLWarning warnings;
    /** Maximum number of rows to fetch for resultset */
    private int maxRows = 0;
    /** Maximum number of rows to fetch for resultset for executeLarge methods */
    //This one isn't used right now
    private long largeMaxRows = 0;
    //These ones are ignored
    private int fetchSize;
    private int fetchDirection = ResultSet.FETCH_UNKNOWN;
    private int resultSetType = ResultSet.TYPE_SCROLL_INSENSITIVE;
    private int resultSetConcurrency = ResultSet.CONCUR_READ_ONLY;
    private int resultSetHoldability = ResultSet.HOLD_CURSORS_OVER_COMMIT;

    /**
     * Default MonetStatement constructor.
     *
     * @param conn the connection that created this Statement
     */
    public MonetStatement(MonetConnection conn) {
        this.conn = conn;
        this.resultSet = null;
        this.batch = new ArrayList<>();
    }

    /**
     * MonetStatement constructor with query timeout value.
     *
     * @param conn the connection that created this Statement
     * @param queryTimeout the timeout before aborting a query execution
     */
    public MonetStatement(MonetConnection conn, int queryTimeout) {
        this.conn = conn;
        this.resultSet = null;
        this.batch = new ArrayList<>();
        this.queryTimeout = queryTimeout;
    }

    //TODO Should we delete this one? We don't use these ResultSet variables
    /**
     * MonetStatement constructor with parameterized result set options.
     *
     * @param conn the connection that created this Statement
     * @param resultSetType type of ResultSet to produce
     * @param resultSetConcurrency concurrency of ResultSet to produce
     * @param resultSetHoldability holdability of ResultSet after commit
     */
    public MonetStatement(MonetConnection conn, int resultSetType, int resultSetConcurrency, int resultSetHoldability) {
        this.conn = conn;
        this.resultSet = null;
        this.resultSetType = resultSetType;
        this.resultSetConcurrency = resultSetConcurrency;
        this.resultSetHoldability = resultSetHoldability;
        this.batch = new ArrayList<>();
    }

    private final void addWarning(final String reason, final String sqlstate) {
        final SQLWarning warn = new SQLWarning(reason, sqlstate);
        if (warnings == null) {
            warnings = warn;
        } else {
            warnings.setNextWarning(warn);
        }
    }

    /**
     * Helper method to test whether the Statement object is closed
     * When closed, it throws an SQLException
     */
    public void checkNotClosed() throws SQLException {
        if (isClosed())
            throw new SQLException("Statement is closed", "M1M20");
    }

    //Close
    /**
     * Releases this Statement object's database and JDBC resources immediately
     * instead of waiting for this to happen when it is automatically closed.
     *
     * Calling the method close on a Statement object that is already closed has
     * no effect.
     *
     * A Statement object is automatically closed when it is garbage collected.
     * When a Statement object is closed, its current ResultSet object, if one
     * exists, is also closed.
     */
    @Override
    public void close() throws SQLException {
        checkNotClosed();
        //If there is a result set and it is not closed, close it
        if (resultSet != null && !resultSet.isClosed()) {
            resultSet.close();
        }
        //If called on a PreparedStatement object, it should free the prepared statement in the database
        if (this instanceof MonetPreparedStatement) {
            //This check is here in case the Prepared Statement was not successful in the prepare stage
            if (((MonetPreparedStatement) this).statementNative != null) {
                MonetNative.monetdbe_cleanup_statement(conn.getDbNative(),((MonetPreparedStatement) this).statementNative);
            }
        }
        closed = true;
    }

    /**
     * Cancels this Statement object if both the DBMS and driver support aborting an SQL statement.
     *
     * This feature is not currently supported.
     *
     * @throws SQLException - if a database access error occurs or this method is called on a closed Statement
     * @throws SQLFeatureNotSupportedException - if the JDBC driver does not support this method
     */
    @Override
    public void cancel() throws SQLException {
        throw new SQLFeatureNotSupportedException("Query cancelling is currently not supported by the driver.", "0A000");
    }

    /**
     * Retrieves whether this Statement object has been closed. A
     * Statement is closed if the method close has been called on it, or
     * if it is automatically closed.
     *
     * @return true if this Statement object is closed; false if it is
     *         still open
     */
    @Override
    public boolean isClosed() throws SQLException {
        return closed;
    }

    /**
     * Specifies that this Statement will be closed when all its
     * dependent result sets are closed.  If execution of the Statement
     * does not produce any result sets, this method has no effect.
     *
     * @throws SQLException if this method is called on a closed Statement
     */
    @Override
    public void closeOnCompletion() throws SQLException {
        checkNotClosed();
        closeOnCompletion = true;
    }

    /**
     * Returns a value indicating whether this Statement will be closed
     * when all its dependent result sets are closed.
     *
     * @return true if the Statement will be closed when all of its
     *         dependent result sets are closed; false otherwise
     * @throws SQLException if this method is called on a closed Statement
     */
    @Override
    public boolean isCloseOnCompletion() throws SQLException {
        checkNotClosed();
        return closeOnCompletion;
    }

    /**
     * Called by the result set object when it is closed
     * Used to close statement if closeOnCompletion() was called
     */
    protected void closeIfComplete () throws SQLException {
        if (!closed && closeOnCompletion) {
            close();
        }
    }

    /**
     * The execute method executes the given SQL statement and indicates the form of
     * the first result. You must then use the methods getResultSet or
     * getUpdateCount to retrieve the result (either a ResultSet object or an int representing the update count).
     *
     * Multiple results may result from the SQL statement, but only the first one may be retrieved in the current version.
     *
     * @param sql any SQL statement
     * @return true if the first result is a ResultSet object; false if it is an
     *         update count or there are no results
     * @throws SQLException if a database access error occurs
     */
    @Override
    public boolean execute(String sql) throws SQLException {
        checkNotClosed();

        int lastUpdateCount = this.updateCount;
        MonetResultSet lastResultSet = this.resultSet;
        this.resultSet = null;
        this.updateCount = -1;

        //ResultSet and UpdateCount is set within monetdbe_query
        String error_msg = MonetNative.monetdbe_query(conn.getDbNative(),sql,this,false, getMaxRows());
        if (error_msg != null) {
            this.updateCount = lastUpdateCount;
            this.resultSet = lastResultSet;
            throw new SQLException(error_msg);
        }
        else if (this.resultSet!=null) {
            return true;
        }
        //Data manipulation and data definition (Statement.SUCCESS_NO_INFO) queries
        else if (this.updateCount >= 0 || this.updateCount == Statement.SUCCESS_NO_INFO){
            return false;
        }
        else {
            throw new SQLException("Error in monetdbe_query");
        }
    }

    /**
     * Executes the given SQL statement, which returns a single ResultSet
     * object.
     *
     * Multiple results may result from the SQL statement, but only the first one may be retrieved in the current version.
     *
     * @param sql an SQL statement to be sent to the database, typically a
     *        static SQL SELECT statement
     * @return a ResultSet object that contains the data produced by the given
     *         query; never null
     * @throws SQLException if a database access error occurs or the given SQL
     *         statement produces anything other than a single ResultSet object
     */
    @Override
    public ResultSet executeQuery(final String sql) throws SQLException {
        if (!execute(sql))
            throw new SQLException("Query did not produce a result set", "M1M19");
        return getResultSet();
    }

    /**
     * Executes the given SQL statement, which may be an INSERT, UPDATE, or
     * DELETE statement or an SQL statement that returns nothing, such as an
     * SQL DDL statement.
     *
     * @param sql an SQL INSERT, UPDATE or DELETE statement or an SQL statement
     *        that returns nothing
     * @return either the row count for INSERT, UPDATE  or DELETE statements, or
     *         0 for SQL statements that return nothing
     * @throws SQLException if a database access error occurs or the given SQL
     *         statement produces a ResultSet object
     */
    @Override
    public int executeUpdate(final String sql) throws SQLException {
        if (execute(sql))
            throw new SQLException("Query produced a result set", "M1M17");
        return getUpdateCount();
    }

    /**
     * Executes the given SQL statement, which may be an INSERT, UPDATE, or
     * DELETE statement or an SQL statement that returns nothing, such as an
     * SQL DDL statement.
     *
     * This method should be used when the returned row count may exceed Integer.MAX_VALUE.
     *
     * @param sql an SQL Data Manipulation Language (DML) statement, such as
     *	INSERT, UPDATE or DELETE; or an SQL statement that returns nothing,
     *	such as a DDL statement.
     * @return either the row count for INSERT, UPDATE  or DELETE statements, or
     *          0 for SQL statements that return nothing
     * @throws SQLException if a database access error occurs, this method is
     *	called on a closed Statement, the given SQL statement produces a
     *	ResultSet object, the method is called on a PreparedStatement or CallableStatement
     */
    @Override
    public long executeLargeUpdate(String sql) throws SQLException {
        checkNotClosed();

        long lastUpdateCount = this.largeUpdateCount;
        MonetResultSet lastResultSet = this.resultSet;
        this.resultSet = null;
        this.largeUpdateCount = -1;

        //ResultSet and UpdateCount is set within monetdbe_query
        String error_msg = MonetNative.monetdbe_query(conn.getDbNative(),sql,this, true, getMaxRows());
        if (error_msg != null) {
            this.largeUpdateCount = lastUpdateCount;
            this.resultSet = lastResultSet;
            throw new SQLException(error_msg);
        }
        else if (this.resultSet!=null) {
            throw new SQLException("Query produced a result set", "M1M17");
        }
        else {
            return getLargeUpdateCount();
        }
    }

    //Batch executes
    @Override
    public int[] executeBatch() throws SQLException {
        checkNotClosed();
        if (batch == null || batch.isEmpty()) {
            return new int[0];
        }
        int[] counts = new int[batch.size()];
        int count = -1;

        for (int i = 0; i < batch.size(); i++) {
            String query = batch.get(i);
            try {
                count = executeUpdate(query);
            } catch (SQLException e) {
                //Query returned a resultSet, throw BatchUpdateException
                throw new BatchUpdateException();
            }
            if (count >= 0) {
                counts[i] = count;
            }
            else {
                counts[i] = Statement.SUCCESS_NO_INFO;
            }
        }
        clearBatch();
        return counts;
    }

    /**
     * Adds the given SQL command to the current list of commmands for this
     * Statement object.  The commands in this list can be executed as a
     * batch by calling the method executeBatch.
     *
     * @param sql typically this is a SQL INSERT or UPDATE statement
     * @throws SQLException if a database access error occurs, this method is called on a closed Statement,
     * the driver does not support batch updatesor the method is called on a PreparedStatement or CallableStatement
     */
    @Override
    public void addBatch(String sql) throws SQLException {
        checkNotClosed();
        if (batch == null) {
            batch = new ArrayList<>();
        }
        batch.add(sql);
    }

    /**
     * Empties this Statement object's current list of SQL commands.
     * @throws  SQLException if a database access error occurs, this method is called on a closed Statement
     * or the driver does not support batch updates
     */
    @Override
    public void clearBatch() throws SQLException {
        checkNotClosed();
        if (batch != null) {
            batch.clear();
        }
    }

    @Override
    public long[] executeLargeBatch() throws SQLException {
        checkNotClosed();
        if (batch == null || batch.isEmpty()) {
            return new long[0];
        }
        long[] counts = new long[batch.size()];
        long count = -1;

        for (int i = 0; i < batch.size(); i++) {
            String query = batch.get(i);
            try {
                count = executeLargeUpdate(query);
            } catch (SQLException e) {
                //Query returned a resultSet, throw BatchUpdateException
                throw new BatchUpdateException();
            }
            if (count >= 0) {
                counts[i] = count;
            }
            else {
                counts[i] = Statement.SUCCESS_NO_INFO;
            }
        }
        clearBatch();
        return counts;
    }

    /**
     * Currently not supported, will throw a SQLFeatureNotSupportedException
     * @param current one of the Statement constants indicating what should happen to current ResultSet objects obtained using the method
     * @return true if the next result is a ResultSet object; false if it is an update count or there are no more results
     * @throws SQLException if a database access error occurs or this method is called on a closed Statement
     * @throws SQLFeatureNotSupportedException if DatabaseMetaData.supportsMultipleOpenResults returns false
     */
    //TODO GETMORERESULTS
    @Override
    public boolean getMoreResults(int current) throws SQLException {
        //Is it possible to have more than one ResultSet returning from a batch query in MonetDBe?
        checkNotClosed();
        throw new SQLFeatureNotSupportedException("getMoreResults()");
    }

    /**
     * Currently not supported, will throw a SQLFeatureNotSupportedException
     *
     * @return true if the next result is a ResultSet object; false if it is an update count or there are no more results
     * @throws SQLException if a database access error occurs or this method is called on a closed Statement
     * @throws SQLFeatureNotSupportedException if DatabaseMetaData.supportsMultipleOpenResults returns false
     */
    @Override
    public boolean getMoreResults() throws SQLException {
        return getMoreResults(Statement.CLOSE_CURRENT_RESULT);
    }

    //Meta gets/sets
    @Override
    public int getUpdateCount() throws SQLException {
        checkNotClosed();
        return this.updateCount;
    }

    @Override
    public ResultSet getResultSet() throws SQLException {
        checkNotClosed();
        return resultSet;
    }

    @Override
    public void setEscapeProcessing(boolean enable) throws SQLException {
        checkNotClosed();
        if (enable)
            addWarning("setEscapeProcessing: JDBC escape syntax is not supported by this driver", "01M22");
    }

    @Override
    public int getQueryTimeout() throws SQLException {
        checkNotClosed();
        return queryTimeout;
    }

    @Override
    public void setQueryTimeout(int seconds) throws SQLException {
        checkNotClosed();
        if (seconds < 0)
            throw new SQLException("Illegal timeout value: " + seconds);
        queryTimeout = seconds;
    }

    @Override
    public SQLWarning getWarnings() throws SQLException {
        checkNotClosed();
        return warnings;
    }

    @Override
    public void clearWarnings() throws SQLException {
        checkNotClosed();
        warnings = null;
    }

    @Override
    public void setCursorName(String name) throws SQLException {
        checkNotClosed();
        addWarning("setCursorName: positioned updates/deletes not supported", "01M21");
    }

    @Override
    public void setFetchDirection(int direction) throws SQLException {
        checkNotClosed();
        if (direction == ResultSet.FETCH_FORWARD ||
                direction == ResultSet.FETCH_REVERSE ||
                direction == ResultSet.FETCH_UNKNOWN)
        {
            fetchDirection = direction;
        } else {
            throw new SQLException("Illegal direction: " + direction, "M1M05");
        }
    }

    @Override
    public int getFetchDirection() throws SQLException {
        checkNotClosed();
        return fetchDirection;
    }

    @Override
    public void setFetchSize(int rows) throws SQLException {
        checkNotClosed();
        if (rows >= 0 && !(getMaxRows() != 0 && rows > getMaxRows())) {
            this.fetchSize = rows;
        } else {
            throw new SQLException("Illegal fetch size value: " + rows, "M1M05");
        }
    }

    @Override
    public int getFetchSize() throws SQLException {
        checkNotClosed();
        return fetchSize;
    }

    @Override
    public int getResultSetConcurrency() throws SQLException {
        checkNotClosed();
        return resultSetConcurrency;
    }

    @Override
    public int getResultSetType() throws SQLException {
        checkNotClosed();
        return resultSetType;
    }

    @Override
    public Connection getConnection() throws SQLException {
        checkNotClosed();
        return conn;
    }

    @Override
    public int getResultSetHoldability() throws SQLException {
        checkNotClosed();
        return resultSetHoldability;
    }

    @Override
    public void setPoolable(boolean poolable) throws SQLException {
        throw new SQLFeatureNotSupportedException("Poolable statements are currently not supported by the driver.");
    }

    @Override
    public boolean isPoolable() throws SQLException {
        checkNotClosed();
        return false;
    }

    @Override
    public long getLargeUpdateCount() throws SQLException {
        checkNotClosed();
        return largeUpdateCount;
    }

    @Override
    public void setLargeMaxRows(long max) throws SQLException {
        checkNotClosed();
        this.largeMaxRows = max;
    }

    @Override
    public long getLargeMaxRows() throws SQLException {
        checkNotClosed();
        return largeMaxRows;
    }

    //The old implementation returned a value which overflows the java int
    @Override
    public int getMaxFieldSize() throws SQLException {
        checkNotClosed();
        // MonetDB supports null terminated strings of max 2GB, see function: int UTF8_strlen();
        //return 2*1024*1024*1024 - 2;
        return Integer.MAX_VALUE;
    }

    @Override
    public void setMaxFieldSize(final int max) throws SQLException {
        checkNotClosed();
        if (max < 0)
            throw new SQLException("Illegal max value: " + max, "M1M05");
        if (max > 0)
            addWarning("setMaxFieldSize: field size limitation not supported", "01M23");
    }

    @Override
    public int getMaxRows() throws SQLException {
        checkNotClosed();
        return maxRows;
    }

    @Override
    public void setMaxRows(int max) throws SQLException {
        checkNotClosed();
        if (max < 0)
            throw new SQLException("Illegal max value: " + max, "M1M05");
        maxRows = max;
    }

    //Auto-generated keys
    //TODO Generated Keys
    @Override
    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        return false;
    }

    @Override
    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
        return false;
    }

    @Override
    public boolean execute(String sql, String[] columnNames) throws SQLException {
        return false;
    }

    @Override
    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        return 0;
    }

    @Override
    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
        return 0;
    }

    @Override
    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        return 0;
    }

    @Override
    public long executeLargeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        return 0;
    }

    @Override
    public long executeLargeUpdate(String sql, int[] columnIndexes) throws SQLException {
        return 0;
    }

    @Override
    public long executeLargeUpdate(String sql, String[] columnNames) throws SQLException {
        return 0;
    }

    //TODO Generated Keys
    @Override
    public ResultSet getGeneratedKeys() throws SQLException {
        return null;
    }
}
